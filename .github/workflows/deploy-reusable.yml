# GitHub Actions CI/CD for Komodo Infrastructure Deployment
# Replaces webhook-based deployment with direct Komodo API calls
# 
# Triggers: Push to main (PR merge, direct push)
# Flow: Validate ‚Üí Detect Changes ‚Üí Deploy via Komodo API
#
# Required Secrets:
#   KOMODO_API_URL      - Komodo API endpoint (e.g., https://komodo.example.com/api)
#   KOMODO_API_KEY      - Komodo API key for authentication
#   KOMODO_API_SECRET   - Komodo API secret for authentication

name: Deploy Infrastructure Reusable

on:
  workflow_call:
    inputs:
      environment:
        description: 'Environment name (e.g., singapore-prod, singapore-qa)'
        required: true
        type: string
      resource_sync_name:
        description: 'ResourceSync name in Komodo'
        required: true
        type: string
      repo_name:
        description: 'Repository name'
        required: true
        type: string
      force_deploy:
        description: 'Force deploy all stacks (ignore change detection)'
        required: false
        default: false
        type: boolean
      redeploy_stacks:
        description: 'Specific stacks to redeploy (comma-separated)'
        required: false
        default: ''
        type: string
      dry_run:
        description: 'Dry run mode (validate only, no deployment)'
        required: false
        default: false
        type: boolean
    secrets:
      KOMODO_API_URL:
        required: true
      KOMODO_API_KEY:
        required: true
      KOMODO_API_SECRET:
        required: true

env:
  ENVIRONMENT: ${{ inputs.environment }}
  RESOURCE_SYNC_NAME: ${{ inputs.resource_sync_name }}
  REPO_NAME: ${{ inputs.repo_name }}

jobs:
  # ============================================================================
  # VALIDATION JOB
  # Validates all configuration files before deployment
  # ============================================================================
  validate:
    name: Validate Configuration
    runs-on: ubuntu-latest
    outputs:
      changes_detected: ${{ steps.detect-changes.outputs.changes_detected }}
      stacks_added: ${{ steps.detect-changes.outputs.stacks_added }}
      stacks_removed: ${{ steps.detect-changes.outputs.stacks_removed }}
      stacks_modified: ${{ steps.detect-changes.outputs.stacks_modified }}
      stacks_current: ${{ steps.detect-changes.outputs.stacks_current }}
      stacks_desired: ${{ steps.detect-changes.outputs.stacks_desired }}
      repos_added: ${{ steps.detect-changes.outputs.repos_added }}
      repos_removed: ${{ steps.detect-changes.outputs.repos_removed }}
      repos_modified: ${{ steps.detect-changes.outputs.repos_modified }}
      repos_current: ${{ steps.detect-changes.outputs.repos_current }}
      repos_desired: ${{ steps.detect-changes.outputs.repos_desired }}
      servers_added: ${{ steps.detect-changes.outputs.servers_added }}
      servers_removed: ${{ steps.detect-changes.outputs.servers_removed }}
      servers_modified: ${{ steps.detect-changes.outputs.servers_modified }}
      servers_current: ${{ steps.detect-changes.outputs.servers_current }}
      servers_desired: ${{ steps.detect-changes.outputs.servers_desired }}
      validation_passed: ${{ steps.final-status.outputs.passed }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2  # Need previous commit for diff
      # ----------------------------------------------------------------------
      # Input Validation - Security: Prevent malicious inputs
      # ----------------------------------------------------------------------
      - name: Validate inputs
        run: |
          echo "üîç Validating workflow inputs..."
          
          # Validate environment name format (alphanumeric, hyphens only)
          if [[ ! "${{ inputs.environment }}" =~ ^[a-z0-9-]+$ ]]; then
            echo "::error::Invalid environment name '${{ inputs.environment }}'. Must contain only lowercase letters, numbers, and hyphens."
            exit 1
          fi
          
          # Validate resource_sync_name format
          if [[ ! "${{ inputs.resource_sync_name }}" =~ ^[a-zA-Z0-9_-]+$ ]]; then
            echo "::error::Invalid resource_sync_name '${{ inputs.resource_sync_name }}'. Must contain only letters, numbers, hyphens, and underscores."
            exit 1
          fi
          
          # Validate repo_name format
          if [[ ! "${{ inputs.repo_name }}" =~ ^[a-zA-Z0-9_-]+$ ]]; then
            echo "::error::Invalid repo_name '${{ inputs.repo_name }}'. Must contain only letters, numbers, hyphens, and underscores."
            exit 1
          fi
          
          # Validate redeploy_stacks format (if provided)
          if [ -n "${{ inputs.redeploy_stacks }}" ]; then
            # Check for valid characters (alphanumeric, hyphens, commas, spaces)
            if [[ ! "${{ inputs.redeploy_stacks }}" =~ ^[a-zA-Z0-9_,-\ ]+$ ]]; then
              echo "::error::Invalid redeploy_stacks '${{ inputs.redeploy_stacks }}'. Contains invalid characters."
              exit 1
            fi
          fi
          
          echo "‚úÖ All inputs validated"



      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          cache: 'pip'

      - name: Install validation tools
        run: |
          # pyyaml for compose validation, requests for API calls
          # tomllib is built-in to Python 3.11+, openssl/jq/curl are pre-installed on ubuntu-latest
          pip install pyyaml requests -q

      # Secret Scanning - Prevent accidental secret commits
      # ----------------------------------------------------------------------
      - name: Scan for unencrypted secrets
        id: secret-scan
        run: |
          echo "üîç Scanning for unencrypted .env files..."
          UNENCRYPTED_FILES=""
          EXIT_CODE=0
          
          # Find all .env files that are NOT .env.encrypted or .env.example
          while IFS= read -r -d '' file; do
            filename=$(basename "$file")
            if [[ "$filename" == ".env" ]]; then
              UNENCRYPTED_FILES="$UNENCRYPTED_FILES$file\n"
              echo "::error file=$file::Unencrypted .env file detected! This file should NOT be committed."
              EXIT_CODE=1
            fi
          done < <(find stacks -name ".env" -type f -print0 2>/dev/null || true)
          
          if [ $EXIT_CODE -eq 1 ]; then
            echo "‚ùå SECURITY VIOLATION: Unencrypted .env files found!"
            echo "unencrypted_found=true" >> $GITHUB_OUTPUT
            exit 1
          else
            echo "‚úÖ No unencrypted .env files found"
            echo "unencrypted_found=false" >> $GITHUB_OUTPUT
          fi

      - name: Verify encrypted files exist for all stacks
        id: verify-encrypted
        run: |
          echo "üîê Verifying .env.encrypted files exist for all stacks..."
          MISSING_ENCRYPTED=""
          EXIT_CODE=0
          
          # Get all stack directories from stacks.toml
          STACK_DIRS=$(grep -oP 'run_directory\s*=\s*"\K[^"]+' stacks/stacks.toml 2>/dev/null || true)
          
          for stack_dir in $STACK_DIRS; do
            if [ -d "$stack_dir" ]; then
              # Check if stack uses additional_env_files (means it needs .env)
              stack_name=$(basename "$stack_dir")
              if [ ! -f "$stack_dir/.env.encrypted" ]; then
                # Check if this stack actually uses env files
                if grep -q "additional_env_files.*\\.env" stacks/stacks.toml; then
                  echo "::warning file=$stack_dir::Missing .env.encrypted for stack: $stack_name"
                  MISSING_ENCRYPTED="$MISSING_ENCRYPTED$stack_dir\n"
                fi
              else
                echo "‚úÖ Found .env.encrypted for $stack_name"
              fi
            fi
          done
          
          if [ -n "$MISSING_ENCRYPTED" ]; then
            echo "‚ö†Ô∏è Some stacks may be missing encrypted environment files"
            echo "missing_found=true" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ All stacks have encrypted environment files"
            echo "missing_found=false" >> $GITHUB_OUTPUT
          fi

      # ----------------------------------------------------------------------
      # TOML Validation
      # ----------------------------------------------------------------------
      - name: Validate TOML syntax
        id: validate-toml
        run: |
          echo "üìã Validating TOML configuration files..."
          EXIT_CODE=0
          
          for toml_file in resource_sync.toml stacks/stacks.toml servers/servers.toml; do
            if [ -f "$toml_file" ]; then
              echo "Checking $toml_file..."
              if python3 -c "import tomllib; tomllib.load(open('$toml_file', 'rb'))" 2>&1; then
                echo "  ‚úÖ $toml_file is valid"
              else
                echo "::error file=$toml_file::Invalid TOML syntax"
                EXIT_CODE=1
              fi
            fi
          done
          
          if [ $EXIT_CODE -eq 1 ]; then
            echo "toml_valid=false" >> $GITHUB_OUTPUT
            exit 1
          else
            echo "toml_valid=true" >> $GITHUB_OUTPUT
          fi

      # ----------------------------------------------------------------------
      # Docker Compose Validation
      # ----------------------------------------------------------------------
      - name: Validate Docker Compose files
        id: validate-compose
        run: |
          echo "üê≥ Validating Docker Compose files..."
          EXIT_CODE=0
          
          # Find all compose files
          for compose_file in $(find stacks -name "compose.yml" -o -name "compose.yaml" 2>/dev/null); do
            echo "Checking $compose_file..."
            stack_dir=$(dirname "$compose_file")
            
            # Create a dummy .env file for validation if it doesn't exist
            if [ ! -f "$stack_dir/.env" ]; then
              touch "$stack_dir/.env.tmp"
              ENV_FILE="$stack_dir/.env.tmp"
            else
              ENV_FILE=""
            fi
            
            # Validate compose file syntax (using docker compose config --quiet)
            cd "$stack_dir"
            if docker compose config --quiet 2>&1 || true; then
              echo "  ‚úÖ $compose_file is valid"
            else
              echo "::warning file=$compose_file::Docker Compose validation warning (may be due to missing .env)"
            fi
            cd - > /dev/null
            
            # Clean up temp file
            [ -n "$ENV_FILE" ] && rm -f "$ENV_FILE"
          done
          
          echo "compose_valid=true" >> $GITHUB_OUTPUT

      # ----------------------------------------------------------------------
      # Komodo Resource Schema Validation
      # ----------------------------------------------------------------------
      - name: Validate Komodo resource schema
        id: validate-schema
        run: |
          echo "üìê Validating Komodo resource schema..."

          python3 << 'EOF'
          import tomllib
          import sys
          import os

          errors = []
          warnings = []
          MATCH_TAG = os.environ.get('ENVIRONMENT')
          
          # Validate stacks.toml
          try:
              with open('stacks/stacks.toml', 'rb') as f:
                  stacks = tomllib.load(f)
              for stack in stacks.get('stack', []):
                  name = stack.get('name', 'unknown')
                  config = stack.get('config', {})
                  
                  # Required fields
                  if not stack.get('name'):
                    errors.append(f"Stack missing 'name' field")
                  if not config.get('server'):
                    errors.append(f"Stack '{name}' missing 'server' in config")
                  if not config.get('run_directory'):
                    errors.append(f"Stack '{name}' missing 'run_directory' in config")
                  
                  # Validate tags include environment tag
                  tags = stack.get('tags', [])
                  if MATCH_TAG not in tags:
                    warnings.append(f"Stack '{name}' missing '{MATCH_TAG}' tag")

                  # Validate linked_repo matches expected pattern (repo-per-server)
                  linked_repo = config.get('linked_repo', '')
                  if linked_repo and not linked_repo.startswith(os.environ.get('REPO_NAME', 'infra-deploy')):
                    warnings.append(f"Stack '{name}' has unexpected linked_repo: {linked_repo}")
          except Exception as e:
              errors.append(f"Failed to parse stacks.toml: {e}")
          
          # Validate servers.toml
          try:
              with open('servers/servers.toml', 'rb') as f:
                  servers = tomllib.load(f)
              server_names = [s.get('name') for s in servers.get('server', [])]
              
              # Check all stacks reference valid servers
              with open('stacks/stacks.toml', 'rb') as f:
                  stacks = tomllib.load(f)
              for stack in stacks.get('stack', []):
                  server = stack.get('config', {}).get('server')
                  if server and server not in server_names:
                      errors.append(f"Stack '{stack.get('name')}' references unknown server '{server}'")
                      
          except Exception as e:
              errors.append(f"Failed to validate server references: {e}")
          
          # Output results
          for warning in warnings:
              print(f"::warning::{warning}")
          
          for error in errors:
              print(f"::error::{error}")
          
          if errors:
              print(f"\n‚ùå Schema validation failed with {len(errors)} error(s)")
              sys.exit(1)
          else:
              print(f"\n‚úÖ Schema validation passed ({len(warnings)} warning(s))")
              sys.exit(0)
          EOF

      # ----------------------------------------------------------------------
      # Change Detection - Compare TOML files against Komodo current state
      # ----------------------------------------------------------------------
      - name: Detect changes against Komodo state
        id: detect-changes
        env:
          KOMODO_API_URL: ${{ secrets.KOMODO_API_URL }}
          KOMODO_API_KEY: ${{ secrets.KOMODO_API_KEY }}
          KOMODO_API_SECRET: ${{ secrets.KOMODO_API_SECRET }}
          DEBUG_KOMODO_PAYLOADS: ${{ vars.KOMODO_DEBUG_PAYLOADS || 'false' }}
        run: |
          echo "üîÑ Comparing desired state against Komodo current state..."
          echo "   (Using optimized parallel API calls)"

          python3 lib/infra-deploy-scripts/scripts/change-detection.py

      # ----------------------------------------------------------------------
      # Final Validation Status
      # ----------------------------------------------------------------------
      - name: Validation summary
        id: final-status
        run: |
          echo "üìã Validation Summary"
          echo "===================="
          echo "Secret Scan: ${{ steps.secret-scan.outputs.unencrypted_found == 'false' && '‚úÖ Passed' || '‚ùå Failed' }}"
          echo "TOML Syntax: ${{ steps.validate-toml.outputs.toml_valid == 'true' && '‚úÖ Passed' || '‚ùå Failed' }}"
          echo "Compose Files: ${{ steps.validate-compose.outputs.compose_valid == 'true' && '‚úÖ Passed' || '‚ö†Ô∏è Warnings' }}"
          echo "Schema: ‚úÖ Passed"
          echo ""
          echo "passed=true" >> $GITHUB_OUTPUT

  # ============================================================================
  # DEPLOY JOB
  # Deploys changes to Komodo via API
  # ============================================================================
  deploy:
    name: Deploy to Komodo
    runs-on: ubuntu-latest
    needs: validate
    if: |
      needs.validate.outputs.validation_passed == 'true' &&
      !inputs.dry_run
    environment: ${{ inputs.environment }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python for deployment
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          cache: 'pip'

      - name: Setup deployment tools
        run: |
          # jq and curl are pre-installed on ubuntu-latest
          # Install requests for any Python API calls if needed
          pip install requests -q

      # ----------------------------------------------------------------------
      # Komodo API Helper Functions
      # ----------------------------------------------------------------------
      - name: Setup Komodo API client
        id: setup-api
        run: |
          # Create API client script with execution polling
          cat > /tmp/komodo-api.sh << 'SCRIPT'
          #!/bin/bash
          
          # Wait for a Komodo execution to complete
          # Usage: wait_for_execution <execution_id> [timeout_seconds]
          wait_for_execution() {
            local exec_id="$1"
            local timeout="${2:-60}"
            local start_time=$(date +%s)
            
            if [ -z "$exec_id" ]; then
              echo "No execution ID provided, skipping wait"
              return 0
            fi
            
            echo "‚è≥ Waiting for execution $exec_id..."
            
            while true; do
              local elapsed=$(($(date +%s) - start_time))
              if [ $elapsed -ge $timeout ]; then
                echo "‚ö†Ô∏è Timeout after ${timeout}s, continuing..."
                return 0
              fi
              
              local status_response=$(curl -s -X POST \
                -H "Content-Type: application/json" \
                -H "X-API-KEY: $KOMODO_API_KEY" \
                -H "X-API-SECRET: $KOMODO_API_SECRET" \
                -d "{\"type\": \"GetExecution\", \"params\": {\"execution\": \"$exec_id\"}}" \
                "$KOMODO_API_URL/read" 2>/dev/null)
              
              local status=$(echo "$status_response" | jq -r '.status // "Unknown"' 2>/dev/null)
              
              case "$status" in
                "Complete"|"Ok")
                  echo "‚úÖ Execution completed (${elapsed}s)"
                  return 0
                  ;;
                "InProgress"|"Pending"|"Running")
                  sleep 1
                  ;;
                "Unknown"|"")
                  # API might not support GetExecution, use short wait
                  sleep 2
                  echo "‚úÖ Proceeding after ${elapsed}s"
                  return 0
                  ;;
                *)
                  echo "‚ö†Ô∏è Execution status: $status"
                  return 0
                  ;;
              esac
            done
          }
          
          # Extract execution ID from response
          get_execution_id() {
            local response="$1"
            echo "$response" | jq -r '._id["$oid"] // ._id // .execution_id // .id // empty' 2>/dev/null
          }
          
          export -f wait_for_execution
          export -f get_execution_id
          SCRIPT
          
          chmod +x /tmp/komodo-api.sh
          source /tmp/komodo-api.sh
          echo "‚úÖ Komodo API client configured"
        env:
          KOMODO_API_URL: ${{ secrets.KOMODO_API_URL }}
          KOMODO_API_KEY: ${{ secrets.KOMODO_API_KEY }}
          KOMODO_API_SECRET: ${{ secrets.KOMODO_API_SECRET }}

      # ----------------------------------------------------------------------
      # Step 1: Handle Removed Stacks BEFORE sync (cleanup old resources)
      # ----------------------------------------------------------------------
      - name: Destroy removed stacks
        if: needs.validate.outputs.stacks_removed != ''
        run: |
          echo "üóëÔ∏è Destroying removed stacks..."
          
          REMOVED_STACKS="${{ needs.validate.outputs.stacks_removed }}"
          
          for stack in $REMOVED_STACKS; do
            echo "Destroying stack: $stack"
            
            RESPONSE=$(curl -s -X POST \
              -H "Content-Type: application/json" \
              -H "X-API-KEY: ${{ secrets.KOMODO_API_KEY }}" \
              -H "X-API-SECRET: ${{ secrets.KOMODO_API_SECRET }}" \
              -d "{
                \"type\": \"DestroyStack\",
                \"params\": {
                  \"stack\": \"$stack\"
                }
              }" \
              "${{ secrets.KOMODO_API_URL }}/execute")
            
            echo "Response for $stack: $RESPONSE"
            
            if echo "$RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
              echo "::warning::Failed to destroy stack $stack: $(echo $RESPONSE | jq -r '.error')"
            else
              echo "‚úÖ Stack $stack destruction initiated"
            fi
          done
        env:
          KOMODO_API_URL: ${{ secrets.KOMODO_API_URL }}

      # ----------------------------------------------------------------------
      # Step 3: Read resource_sync.toml and create/update ResourceSync via API
      # ----------------------------------------------------------------------
      - name: Create or update ResourceSync from file
        id: ensure-resource-sync
        run: |
          echo "üîß Reading ResourceSync config from resource_sync.toml..."
          
          # Parse resource_sync.toml and extract config (tomllib is built-in to Python 3.11+)
          CONFIG_JSON=$(python3 << 'EOF'
          import tomllib
          import json
          
          with open('resource_sync.toml', 'rb') as f:
              config = tomllib.load(f)
          
          rs = config.get('resource_sync', {})
          print(json.dumps({
              "name": rs.get('name', ''),
              "tags": rs.get('tags', []),
              "config": rs.get('config', {})
          }))
          EOF
          )
          
          echo "Parsed config: $CONFIG_JSON"
          
          RS_NAME=$(echo "$CONFIG_JSON" | jq -r '.name')
          RS_TAGS=$(echo "$CONFIG_JSON" | jq -c '.tags')
          RS_CONFIG=$(echo "$CONFIG_JSON" | jq -c '.config')
          
          echo "ResourceSync name: $RS_NAME"
          echo "ResourceSync tags: $RS_TAGS"
          echo "ResourceSync config: $RS_CONFIG"

              # Enforce delete=false
              RS_CONFIG="$RS_CONFIG" python3 -c "import json,os,sys; cfg=json.loads(os.environ.get('RS_CONFIG','{}')); flag=cfg.get('delete', None); (print('‚úÖ resource_sync.config.delete is false') if flag is False else (print(f'::error::CRITICAL: resource_sync.config.delete must be false (found: {flag})') or sys.exit(1)))"
          
          # Verify match_tags is present
          MATCH_TAGS=$(echo "$RS_CONFIG" | jq -c '.match_tags // empty')
          if [ -z "$MATCH_TAGS" ] || [ "$MATCH_TAGS" = "null" ]; then
            echo "::error::CRITICAL: match_tags is missing from config! This would delete all resources."
            exit 1
          fi
          echo "‚úÖ match_tags present: $MATCH_TAGS"
          
          # Check if ResourceSync exists
          CHECK_RESPONSE=$(curl -s -X POST \
            -H "Content-Type: application/json" \
            -H "X-API-KEY: ${{ secrets.KOMODO_API_KEY }}" \
            -H "X-API-SECRET: ${{ secrets.KOMODO_API_SECRET }}" \
            -d "{
              \"type\": \"GetResourceSync\",
              \"params\": {
                \"sync\": \"$RS_NAME\"
              }
            }" \
            "${{ secrets.KOMODO_API_URL }}/read")
          
          echo "Check response: $CHECK_RESPONSE"
          
          # If not found, create it; otherwise update it
          if echo "$CHECK_RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
            echo "üìù ResourceSync not found, creating..."
            
            CREATE_RESPONSE=$(curl -s -X POST \
              -H "Content-Type: application/json" \
              -H "X-API-KEY: ${{ secrets.KOMODO_API_KEY }}" \
              -H "X-API-SECRET: ${{ secrets.KOMODO_API_SECRET }}" \
              -d "{
                \"type\": \"CreateResourceSync\",
                \"params\": {
                  \"name\": \"$RS_NAME\",
                  \"tags\": $RS_TAGS,
                  \"config\": $RS_CONFIG
                }
              }" \
              "${{ secrets.KOMODO_API_URL }}/write")
            
            echo "Create response: $CREATE_RESPONSE"
            
            if echo "$CREATE_RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
              echo "::error::Failed to create ResourceSync: $(echo $CREATE_RESPONSE | jq -r '.error')"
              exit 1
            fi
            
            echo "‚úÖ ResourceSync created from resource_sync.toml"
          else
            echo "üìù ResourceSync exists, updating config..."
            
            UPDATE_RESPONSE=$(curl -s -X POST \
              -H "Content-Type: application/json" \
              -H "X-API-KEY: ${{ secrets.KOMODO_API_KEY }}" \
              -H "X-API-SECRET: ${{ secrets.KOMODO_API_SECRET }}" \
              -d "{
                \"type\": \"UpdateResourceSync\",
                \"params\": {
                  \"id\": \"$RS_NAME\",
                  \"tags\": $RS_TAGS,
                  \"config\": $RS_CONFIG
                }
              }" \
              "${{ secrets.KOMODO_API_URL }}/write")
            
            echo "Update response: $UPDATE_RESPONSE"
            echo "‚úÖ ResourceSync updated from resource_sync.toml"
          fi
          
          # Export name for subsequent steps
          echo "sync_name=$RS_NAME" >> $GITHUB_OUTPUT
        env:
          KOMODO_API_URL: ${{ secrets.KOMODO_API_URL }}

      - name: Sync Komodo resources
        id: sync-resources
        run: |
          echo "üîÑ Syncing Komodo resources..."
          
          RESPONSE=$(curl -s -X POST \
            -H "Content-Type: application/json" \
            -H "X-API-KEY: ${{ secrets.KOMODO_API_KEY }}" \
            -H "X-API-SECRET: ${{ secrets.KOMODO_API_SECRET }}" \
            -d '{
              "type": "RunSync",
              "params": {
                "sync": "${{ env.RESOURCE_SYNC_NAME }}"
              }
            }' \
            "${{ secrets.KOMODO_API_URL }}/execute")
          
          echo "Response: $RESPONSE"
          
          if echo "$RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
            echo "::error::Failed to sync resources: $(echo $RESPONSE | jq -r '.error')"
            exit 1
          fi
          
          # Extract execution ID and wait for completion
          EXECUTION_ID=$(echo "$RESPONSE" | jq -r '._id["$oid"] // ._id // .execution_id // .id // empty')
          echo "execution_id=$EXECUTION_ID" >> $GITHUB_OUTPUT
          
          if [ -n "$EXECUTION_ID" ]; then
            echo "‚è≥ Waiting for sync to complete (execution: $EXECUTION_ID)..."
            START_TIME=$(date +%s)
            TIMEOUT=30
            
            while true; do
              ELAPSED=$(($(date +%s) - START_TIME))
              if [ $ELAPSED -ge $TIMEOUT ]; then
                echo "‚úÖ Proceeding after ${ELAPSED}s"
                break
              fi
              
              STATUS_RESP=$(curl -s -X POST \
                -H "Content-Type: application/json" \
                -H "X-API-KEY: ${{ secrets.KOMODO_API_KEY }}" \
                -H "X-API-SECRET: ${{ secrets.KOMODO_API_SECRET }}" \
                -d "{\"type\": \"GetExecution\", \"params\": {\"execution\": \"$EXECUTION_ID\"}}" \
                "${{ secrets.KOMODO_API_URL }}/read" 2>/dev/null || echo '{}')
              
              STATUS=$(echo "$STATUS_RESP" | jq -r '.status // "Unknown"' 2>/dev/null)
              
              if [ "$STATUS" = "Complete" ] || [ "$STATUS" = "Ok" ]; then
                echo "‚úÖ Sync completed in ${ELAPSED}s"
                break
              elif [ "$STATUS" = "InProgress" ] || [ "$STATUS" = "Pending" ]; then
                sleep 1
              else
                echo "‚úÖ Proceeding (status: $STATUS)"
                break
              fi
            done
          fi
          
          echo "‚úÖ Resource sync initiated"
        env:
          KOMODO_API_URL: ${{ secrets.KOMODO_API_URL }}

      # ----------------------------------------------------------------------
      # Step 4: Clone All Repos (if not already cloned)
      # ResourceSync only creates the repo resources, doesn't clone them
      # We need to clone each repo on each server
      # ----------------------------------------------------------------------
      - name: Clone repositories in Komodo
        id: clone-repos
        run: |
          echo "üì• Cloning repositories in Komodo..."
          
          # Get all repos with our tag
          REPOS_RESPONSE=$(curl -s -X POST \
            -H "Content-Type: application/json" \
            -H "X-API-KEY: ${{ secrets.KOMODO_API_KEY }}" \
            -H "X-API-SECRET: ${{ secrets.KOMODO_API_SECRET }}" \
            -d '{
              "type": "ListRepos",
              "params": {
                "query": {
                  "tags": ["${{ env.ENVIRONMENT }}"]
                }
              }
            }' \
            "${{ secrets.KOMODO_API_URL }}/read")
          
          echo "Found repos: $(echo "$REPOS_RESPONSE" | jq -r '.[].name' 2>/dev/null || echo 'none')"
          
          # Clone each repo in parallel (up to 5 concurrent)
          REPO_LIST=$(echo "$REPOS_RESPONSE" | jq -r '.[].name' 2>/dev/null | sort | uniq)
          REPO_COUNT=$(echo "$REPO_LIST" | grep -c . || echo "0")

          if [ "$REPO_COUNT" -gt 0 ]; then
            echo "üì• Cloning $REPO_COUNT repo(s) in parallel..."

            # Export secrets for subshell
            export KOMODO_API_URL KOMODO_API_KEY KOMODO_API_SECRET

            echo "$REPO_LIST" | xargs -P 5 -I {} sh -c '
              REPO_NAME="$1"
              echo "  üì• Cloning $REPO_NAME..."

              RESPONSE=$(curl -s -X POST \
                -H "Content-Type: application/json" \
                -H "X-API-KEY: $KOMODO_API_KEY" \
                -H "X-API-SECRET: $KOMODO_API_SECRET" \
                -d "{
                  \"type\": \"CloneRepo\",
                  \"params\": {
                    \"repo\": \"$REPO_NAME\"
                  }
                }" \
                "$KOMODO_API_URL/execute" 2>&1)

              # Clone may fail if already cloned - that is OK
              if echo "$RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
                ERROR_MSG=$(echo "$RESPONSE" | jq -r '.error' 2>/dev/null)
                if [[ "$ERROR_MSG" == *"already"* ]] || [[ "$ERROR_MSG" == *"exists"* ]]; then
                  echo "  ‚ÑπÔ∏è $REPO_NAME already cloned"
                else
                  echo "  ‚ö†Ô∏è $REPO_NAME: $ERROR_MSG"
                fi
              else
                echo "  ‚úÖ $REPO_NAME clone initiated"
              fi
            ' sh {} "$REPO_NAME"

            echo "‚úÖ All clone operations completed"
          else
            echo "No repos to clone"
          fi
        env:
          KOMODO_API_URL: ${{ secrets.KOMODO_API_URL }}

      # ----------------------------------------------------------------------
      # Step 5: Pull All Repos (triggers decryption via on_pull hook)
      # ----------------------------------------------------------------------
      - name: Pull repositories in Komodo
        id: pull-repos
        run: |
          echo "üì• Pulling repositories in Komodo..."
          
          # Get all repos with our tag
          REPOS_RESPONSE=$(curl -s -X POST \
            -H "Content-Type: application/json" \
            -H "X-API-KEY: ${{ secrets.KOMODO_API_KEY }}" \
            -H "X-API-SECRET: ${{ secrets.KOMODO_API_SECRET }}" \
            -d '{
              "type": "ListRepos",
              "params": {
                "query": {
                  "tags": ["${{ env.ENVIRONMENT }}"]
                }
              }
            }' \
            "${{ secrets.KOMODO_API_URL }}/read")
          
          # Pull each repo and collect execution IDs
          EXEC_IDS=()
          FAILED=0
          for REPO_NAME in $(echo "$REPOS_RESPONSE" | jq -r '.[].name' 2>/dev/null | sort | uniq); do
            echo "üì• Pulling $REPO_NAME..."
            
            RESPONSE=$(curl -s -X POST \
              -H "Content-Type: application/json" \
              -H "X-API-KEY: ${{ secrets.KOMODO_API_KEY }}" \
              -H "X-API-SECRET: ${{ secrets.KOMODO_API_SECRET }}" \
              -d "{
                \"type\": \"PullRepo\",
                \"params\": {
                  \"repo\": \"$REPO_NAME\"
                }
              }" \
              "${{ secrets.KOMODO_API_URL }}/execute")
            
            if echo "$RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
              echo "  ‚ùå $REPO_NAME: $(echo $RESPONSE | jq -r '.error')"
              FAILED=1
            else
              EXEC_ID=$(echo "$RESPONSE" | jq -r '._id["$oid"] // ._id // empty')
              [ -n "$EXEC_ID" ] && EXEC_IDS+=("$EXEC_ID")
              echo "  ‚úÖ $REPO_NAME pull initiated"
            fi
          done
          
          if [ $FAILED -eq 1 ]; then
            echo "::warning::Some repository pulls failed"
          fi
          
          # Wait for pulls to complete (decryption hooks run during pull)
          if [ ${#EXEC_IDS[@]} -gt 0 ]; then
            echo "‚è≥ Waiting for ${#EXEC_IDS[@]} pull(s) and decryption to complete..."
            START_TIME=$(date +%s)
            TIMEOUT=20
            
            # Poll first execution as a proxy for all
            FIRST_EXEC="${EXEC_IDS[0]}"
            while true; do
              ELAPSED=$(($(date +%s) - START_TIME))
              if [ $ELAPSED -ge $TIMEOUT ]; then
                echo "‚úÖ Proceeding after ${ELAPSED}s"
                break
              fi
              
              STATUS_RESP=$(curl -s -X POST \
                -H "Content-Type: application/json" \
                -H "X-API-KEY: ${{ secrets.KOMODO_API_KEY }}" \
                -H "X-API-SECRET: ${{ secrets.KOMODO_API_SECRET }}" \
                -d "{\"type\": \"GetExecution\", \"params\": {\"execution\": \"$FIRST_EXEC\"}}" \
                "${{ secrets.KOMODO_API_URL }}/read" 2>/dev/null || echo '{}')
              
              STATUS=$(echo "$STATUS_RESP" | jq -r '.status // "Unknown"' 2>/dev/null)
              
              if [ "$STATUS" = "Complete" ] || [ "$STATUS" = "Ok" ]; then
                echo "‚úÖ Pulls completed in ${ELAPSED}s"
                break
              elif [ "$STATUS" = "InProgress" ] || [ "$STATUS" = "Pending" ]; then
                sleep 1
              else
                echo "‚úÖ Proceeding (status: $STATUS)"
                break
              fi
            done
          fi
          
          echo "‚úÖ Repository pulls completed (decryption triggered)"
        env:
          KOMODO_API_URL: ${{ secrets.KOMODO_API_URL }}

      # ----------------------------------------------------------------------
      # Step 6: Deploy Stacks
      # ----------------------------------------------------------------------
      - name: Deploy stacks
        id: deploy-stacks
        run: |
          echo "üöÄ Deploying stacks..."

          FORCE_DEPLOY="${{ inputs.force_deploy == true && 'true' || 'false' }}"
          REDEPLOY_STACKS="${{ inputs.redeploy_stacks }}"
          
          # If specific stacks are requested, deploy them individually
          if [ -n "$REDEPLOY_STACKS" ]; then
            echo "üì¶ Targeted redeploy requested for: $REDEPLOY_STACKS"
            
            IFS=',' read -ra STACKS <<< "$REDEPLOY_STACKS"
            FAILED_COUNT=0
            SUCCESS_COUNT=0
            
            for STACK in "${STACKS[@]}"; do
              STACK=$(echo "$STACK" | xargs)  # Trim whitespace
              echo "  üîÑ Deploying stack: $STACK"
              
              RESPONSE=$(curl -s -X POST \
                -H "Content-Type: application/json" \
                -H "X-API-KEY: ${{ secrets.KOMODO_API_KEY }}" \
                -H "X-API-SECRET: ${{ secrets.KOMODO_API_SECRET }}" \
                -d "{
                  \"type\": \"DeployStack\",
                  \"params\": {
                    \"stack\": \"$STACK\"
                  }
                }" \
                "${{ secrets.KOMODO_API_URL }}/execute")
              
              if echo "$RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
                echo "::warning::Failed to deploy $STACK: $(echo $RESPONSE | jq -r '.error')"
                ((FAILED_COUNT++))
              else
                EXEC_ID=$(echo "$RESPONSE" | jq -r '.id // empty')
                echo "    ‚úÖ Deployment started (execution: $EXEC_ID)"
                ((SUCCESS_COUNT++))
              fi
            done
            
            echo "üìä Targeted deployment: $SUCCESS_COUNT succeeded, $FAILED_COUNT failed"
            
            if [ "$FAILED_COUNT" -gt 0 ]; then
              exit 1
            fi
          elif [ "$FORCE_DEPLOY" == "true" ]; then
            echo "Force deploy enabled - deploying all stacks"
            DEPLOY_TYPE="BatchDeployStack"
            
            RESPONSE=$(curl -s -X POST \
              -H "Content-Type: application/json" \
              -H "X-API-KEY: ${{ secrets.KOMODO_API_KEY }}" \
              -H "X-API-SECRET: ${{ secrets.KOMODO_API_SECRET }}" \
              -d "{
                \"type\": \"$DEPLOY_TYPE\",
                \"params\": {
                  \"pattern\": \"${{ env.ENVIRONMENT }}-*\"
                }
              }" \
              "${{ secrets.KOMODO_API_URL }}/execute")
            
            echo "Response: $RESPONSE"
            
            # Handle batch response
            if echo "$RESPONSE" | jq -e 'type == "array"' > /dev/null 2>&1; then
              TOTAL=$(echo "$RESPONSE" | jq 'length')
              SUCCESS=$(echo "$RESPONSE" | jq '[.[] | select(.status == "Ok")] | length')
              FAILED=$(echo "$RESPONSE" | jq '[.[] | select(.status != "Ok")] | length')
              
              echo "üìä Batch deployment results: $SUCCESS/$TOTAL succeeded"
              
              if [ "$FAILED" -gt 0 ]; then
                echo "::warning::$FAILED stack(s) failed to deploy"
              fi
            else
              if echo "$RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
                echo "::error::Failed to deploy stacks: $(echo $RESPONSE | jq -r '.error')"
                exit 1
              fi
              echo "‚úÖ Stack deployment initiated"
            fi
          else
            echo "Deploying changed stacks only"
            
            RESPONSE=$(curl -s -X POST \
              -H "Content-Type: application/json" \
              -H "X-API-KEY: ${{ secrets.KOMODO_API_KEY }}" \
              -H "X-API-SECRET: ${{ secrets.KOMODO_API_SECRET }}" \
              -d "{
                \"type\": \"BatchDeployStackIfChanged\",
                \"params\": {
                  \"pattern\": \"${{ env.ENVIRONMENT }}-*\"
                }
              }" \
              "${{ secrets.KOMODO_API_URL }}/execute")
            
            echo "Response: $RESPONSE"
            
            if echo "$RESPONSE" | jq -e 'type == "array"' > /dev/null 2>&1; then
              TOTAL=$(echo "$RESPONSE" | jq 'length')
              SUCCESS=$(echo "$RESPONSE" | jq '[.[] | select(.status == "Ok")] | length')
              FAILED=$(echo "$RESPONSE" | jq '[.[] | select(.status != "Ok")] | length')
              
              echo "üìä Batch deployment results: $SUCCESS/$TOTAL succeeded"
              
              if [ "$FAILED" -gt 0 ]; then
                echo "::warning::$FAILED stack(s) failed to deploy"
              fi
            else
              if echo "$RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
                echo "::error::Failed to deploy stacks: $(echo $RESPONSE | jq -r '.error')"
                exit 1
              fi
              echo "‚úÖ Stack deployment initiated"
            fi
          fi
        env:
          KOMODO_API_URL: ${{ secrets.KOMODO_API_URL }}

      # ----------------------------------------------------------------------
      # Deployment Summary
      # ----------------------------------------------------------------------
      - name: Deployment summary
        run: |
          echo "## üöÄ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Step | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Repository Clone | ‚úÖ Completed |" >> $GITHUB_STEP_SUMMARY
          echo "| Repository Pull | ‚úÖ Completed |" >> $GITHUB_STEP_SUMMARY
          echo "| Resource Sync | ‚úÖ Completed |" >> $GITHUB_STEP_SUMMARY
          echo "| Stack Deployment | ‚úÖ Initiated |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Helper function to format list (newline separated)
          format_list() {
            local items="$1"
            if [ -z "$items" ]; then
              echo "None"
            else
              # Replace escaped newlines with actual newlines, then format as bullet list
              echo "$items" | sed 's/\\n/\n/g' | while read -r item; do
                [ -n "$item" ] && echo "- \`$item\`"
              done
            fi
          }
          
          echo "### üì¶ Stacks" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**‚ûï Added:**" >> $GITHUB_STEP_SUMMARY
          format_list "${{ needs.validate.outputs.stacks_added }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**‚úèÔ∏è Modified:**" >> $GITHUB_STEP_SUMMARY
          format_list "${{ needs.validate.outputs.stacks_modified }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**‚ûñ Removed:**" >> $GITHUB_STEP_SUMMARY
          format_list "${{ needs.validate.outputs.stacks_removed }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**üìç Current (Komodo):**" >> $GITHUB_STEP_SUMMARY
          format_list "${{ needs.validate.outputs.stacks_current }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**üéØ Desired (from TOML):**" >> $GITHUB_STEP_SUMMARY
          format_list "${{ needs.validate.outputs.stacks_desired }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### üìÅ Repos" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**‚ûï Added:**" >> $GITHUB_STEP_SUMMARY
          format_list "${{ needs.validate.outputs.repos_added }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**‚úèÔ∏è Modified:**" >> $GITHUB_STEP_SUMMARY
          format_list "${{ needs.validate.outputs.repos_modified }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**‚ûñ Removed:**" >> $GITHUB_STEP_SUMMARY
          format_list "${{ needs.validate.outputs.repos_removed }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**üìç Current (Komodo):**" >> $GITHUB_STEP_SUMMARY
          format_list "${{ needs.validate.outputs.repos_current }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**üéØ Desired (from TOML):**" >> $GITHUB_STEP_SUMMARY
          format_list "${{ needs.validate.outputs.repos_desired }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### üñ•Ô∏è Servers" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**‚ûï Added:**" >> $GITHUB_STEP_SUMMARY
          format_list "${{ needs.validate.outputs.servers_added }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**‚úèÔ∏è Modified:**" >> $GITHUB_STEP_SUMMARY
          format_list "${{ needs.validate.outputs.servers_modified }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**‚ûñ Removed:**" >> $GITHUB_STEP_SUMMARY
          format_list "${{ needs.validate.outputs.servers_removed }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**üìç Current (Komodo):**" >> $GITHUB_STEP_SUMMARY
          format_list "${{ needs.validate.outputs.servers_current }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**üéØ Desired (from TOML):**" >> $GITHUB_STEP_SUMMARY
          format_list "${{ needs.validate.outputs.servers_desired }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ env.ENVIRONMENT }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Actor:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY

  # ============================================================================
  # NOTIFICATION JOB (Placeholder for Teams integration)
  # ============================================================================
  notify:
    name: Send Notifications
    runs-on: ubuntu-latest
    needs: [validate, deploy]
    if: always()
    
    steps:
      - name: Prepare notification
        run: |
          # Placeholder for Teams notification
          # Will be implemented when Teams webhook is configured
          echo "üì¢ Deployment notification would be sent here"
          echo ""
          echo "Status: ${{ needs.deploy.result }}"
          echo "Environment: ${{ env.ENVIRONMENT }}"
          echo "Commit: ${{ github.sha }}"
          echo "Actor: ${{ github.actor }}"
