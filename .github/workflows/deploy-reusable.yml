# GitHub Actions CI/CD for Komodo Infrastructure Deployment
# Replaces webhook-based deployment with direct Komodo API calls
# 
# Triggers: Push to main (PR merge, direct push)
# Flow: Validate ‚Üí Detect Changes ‚Üí Deploy via Komodo API
#
# Required Secrets:
#   KOMODO_API_URL      - Komodo API endpoint (e.g., https://komodo.example.com/api)
#   KOMODO_API_KEY      - Komodo API key for authentication
#   KOMODO_API_SECRET   - Komodo API secret for authentication

name: Deploy Infrastructure (Reusable)

on:
  workflow_call:
    inputs:
      environment:
        description: 'Environment name (e.g., singapore-prod, singapore-qa)'
        required: true
        type: string
      resource_sync_name:
        description: 'ResourceSync name in Komodo'
        required: true
        type: string
      repo_name:
        description: 'Repository name'
        required: true
        type: string
      force_deploy:
        description: 'Force deploy all stacks (ignore change detection)'
        required: false
        default: false
        type: boolean
      redeploy_stacks:
        description: 'Specific stacks to redeploy (comma-separated)'
        required: false
        default: ''
        type: string
      dry_run:
        description: 'Dry run mode (validate only, no deployment)'
        required: false
        default: false
        type: boolean
    secrets:
      KOMODO_API_URL:
        required: true
      KOMODO_API_KEY:
        required: true
      KOMODO_API_SECRET:
        required: true

env:
  ENVIRONMENT: ${{ inputs.environment }}
  RESOURCE_SYNC_NAME: ${{ inputs.resource_sync_name }}
  REPO_NAME: ${{ inputs.repo_name }}

jobs:
  # ============================================================================
  # VALIDATION JOB
  # Validates all configuration files before deployment
  # ============================================================================
  validate:
    name: Validate Configuration
    runs-on: ubuntu-latest
    outputs:
      changes_detected: ${{ steps.detect-changes.outputs.changes_detected }}
      stacks_added: ${{ steps.detect-changes.outputs.stacks_added }}
      stacks_removed: ${{ steps.detect-changes.outputs.stacks_removed }}
      stacks_modified: ${{ steps.detect-changes.outputs.stacks_modified }}
      stacks_current: ${{ steps.detect-changes.outputs.stacks_current }}
      stacks_desired: ${{ steps.detect-changes.outputs.stacks_desired }}
      repos_added: ${{ steps.detect-changes.outputs.repos_added }}
      repos_removed: ${{ steps.detect-changes.outputs.repos_removed }}
      repos_modified: ${{ steps.detect-changes.outputs.repos_modified }}
      repos_current: ${{ steps.detect-changes.outputs.repos_current }}
      repos_desired: ${{ steps.detect-changes.outputs.repos_desired }}
      servers_added: ${{ steps.detect-changes.outputs.servers_added }}
      servers_removed: ${{ steps.detect-changes.outputs.servers_removed }}
      servers_modified: ${{ steps.detect-changes.outputs.servers_modified }}
      servers_current: ${{ steps.detect-changes.outputs.servers_current }}
      servers_desired: ${{ steps.detect-changes.outputs.servers_desired }}
      validation_passed: ${{ steps.final-status.outputs.passed }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2  # Need previous commit for diff
      # ----------------------------------------------------------------------
      # Input Validation - Security: Prevent malicious inputs
      # ----------------------------------------------------------------------
      - name: Validate inputs
        run: |
          echo "üîç Validating workflow inputs..."
          
          # Validate environment name format (alphanumeric, hyphens only)
          if [[ ! "${{ inputs.environment }}" =~ ^[a-z0-9-]+$ ]]; then
            echo "::error::Invalid environment name '${{ inputs.environment }}'. Must contain only lowercase letters, numbers, and hyphens."
            exit 1
          fi
          
          # Validate resource_sync_name format
          if [[ ! "${{ inputs.resource_sync_name }}" =~ ^[a-zA-Z0-9_-]+$ ]]; then
            echo "::error::Invalid resource_sync_name '${{ inputs.resource_sync_name }}'. Must contain only letters, numbers, hyphens, and underscores."
            exit 1
          fi
          
          # Validate repo_name format
          if [[ ! "${{ inputs.repo_name }}" =~ ^[a-zA-Z0-9_-]+$ ]]; then
            echo "::error::Invalid repo_name '${{ inputs.repo_name }}'. Must contain only letters, numbers, hyphens, and underscores."
            exit 1
          fi
          
          # Validate redeploy_stacks format (if provided)
          if [ -n "${{ inputs.redeploy_stacks }}" ]; then
            # Check for valid characters (alphanumeric, hyphens, commas, spaces)
            if [[ ! "${{ inputs.redeploy_stacks }}" =~ ^[a-zA-Z0-9_,-\ ]+$ ]]; then
              echo "::error::Invalid redeploy_stacks '${{ inputs.redeploy_stacks }}'. Contains invalid characters."
              exit 1
            fi
          fi
          
          echo "‚úÖ All inputs validated"



      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install validation tools
        run: |
          # pyyaml for compose validation, requests for API calls
          # tomllib is built-in to Python 3.11+, openssl/jq/curl are pre-installed on ubuntu-latest
          pip install pyyaml requests -q
      
      - name: Setup secure API helpers
        run: |
          # API helper functions for secure JSON encoding
api_call() {
    local endpoint="$1"
    shift
    local payload
    payload=$(jq -n "$@")
    
    curl -s -X POST \
      -H "Content-Type: application/json" \
      -H "X-API-KEY": ${{ secrets.KOMODO_API_KEY }} \
      -H "X-API-SECRET": ${{ secrets.KOMODO_API_SECRET }} \
      --data-binary @- \
      "${{ secrets.KOMODO_API_URL }}/$endpoint" <<< "$payload"
}

# Export for use in subshells

# Retry helper for transient failures
retry_api_call() {
    local max_attempts=3
    local attempt=1
    local response=""
    local exit_code=0
    
    while [ $attempt -le $max_attempts ]; do
        echo "üîÑ API attempt $attempt/$max_attempts..." >&2
        response=$(eval "$@")
        exit_code=$?
        
        if [ $exit_code -eq 0 ]; then
            echo "$response"
            return 0
        fi
        
        if [ $attempt -lt $max_attempts ]; then
            local wait_time=$((attempt * 2))
            echo "‚ö†Ô∏è Request failed, waiting ${wait_time}s before retry..." >&2
            sleep $wait_time
        fi
        
        attempt=$((attempt + 1))
    done
    
    echo "$response"
    return $exit_code
}

export -f retry_api_call

export -f api_call
        env:
          KOMODO_API_URL: ${{ secrets.KOMODO_API_URL }}
          KOMODO_API_KEY: ${{ secrets.KOMODO_API_KEY }}
          KOMODO_API_SECRET: ${{ secrets.KOMODO_API_SECRET }}


      # ----------------------------------------------------------------------
      # Secret Scanning - Prevent accidental secret commits
      # ----------------------------------------------------------------------
      - name: Scan for unencrypted secrets
        id: secret-scan
        run: |
          echo "üîç Scanning for unencrypted .env files..."
          UNENCRYPTED_FILES=""
          EXIT_CODE=0
          
          # Find all .env files that are NOT .env.encrypted or .env.example
          while IFS= read -r -d '' file; do
            filename=$(basename "$file")
            if [[ "$filename" == ".env" ]]; then
              UNENCRYPTED_FILES="$UNENCRYPTED_FILES$file\n"
              echo "::error file=$file::Unencrypted .env file detected! This file should NOT be committed."
              EXIT_CODE=1
            fi
          done < <(find stacks -name ".env" -type f -print0 2>/dev/null || true)
          
          if [ $EXIT_CODE -eq 1 ]; then
            echo "‚ùå SECURITY VIOLATION: Unencrypted .env files found!"
            echo "unencrypted_found=true" >> $GITHUB_OUTPUT
            exit 1
          else
            echo "‚úÖ No unencrypted .env files found"
            echo "unencrypted_found=false" >> $GITHUB_OUTPUT
          fi

      - name: Verify encrypted files exist for all stacks
        id: verify-encrypted
        run: |
          echo "üîê Verifying .env.encrypted files exist for all stacks..."
          MISSING_ENCRYPTED=""
          EXIT_CODE=0
          
          # Get all stack directories from stacks.toml
          STACK_DIRS=$(grep -oP 'run_directory\s*=\s*"\K[^"]+' stacks/stacks.toml 2>/dev/null || true)
          
          for stack_dir in $STACK_DIRS; do
            if [ -d "$stack_dir" ]; then
              # Check if stack uses additional_env_files (means it needs .env)
              stack_name=$(basename "$stack_dir")
              if [ ! -f "$stack_dir/.env.encrypted" ]; then
                # Check if this stack actually uses env files
                if grep -q "additional_env_files.*\\.env" stacks/stacks.toml; then
                  echo "::warning file=$stack_dir::Missing .env.encrypted for stack: $stack_name"
                  MISSING_ENCRYPTED="$MISSING_ENCRYPTED$stack_dir\n"
                fi
              else
                echo "‚úÖ Found .env.encrypted for $stack_name"
              fi
            fi
          done
          
          if [ -n "$MISSING_ENCRYPTED" ]; then
            echo "‚ö†Ô∏è Some stacks may be missing encrypted environment files"
            echo "missing_found=true" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ All stacks have encrypted environment files"
            echo "missing_found=false" >> $GITHUB_OUTPUT
          fi

      # ----------------------------------------------------------------------
      # TOML Validation
      # ----------------------------------------------------------------------
      - name: Validate TOML syntax
        id: validate-toml
        run: |
          echo "üìã Validating TOML configuration files..."
          EXIT_CODE=0
          
          for toml_file in resource_sync.toml stacks/stacks.toml servers/servers.toml; do
            if [ -f "$toml_file" ]; then
              echo "Checking $toml_file..."
              if python3 -c "import tomllib; tomllib.load(open('$toml_file', 'rb'))" 2>&1; then
                echo "  ‚úÖ $toml_file is valid"
              else
                echo "::error file=$toml_file::Invalid TOML syntax"
                EXIT_CODE=1
              fi
            fi
          done
          
          if [ $EXIT_CODE -eq 1 ]; then
            echo "toml_valid=false" >> $GITHUB_OUTPUT
            exit 1
          else
            echo "toml_valid=true" >> $GITHUB_OUTPUT
          fi

      # ----------------------------------------------------------------------
      # Docker Compose Validation
      # ----------------------------------------------------------------------
      - name: Validate Docker Compose files
        id: validate-compose
        run: |
          echo "üê≥ Validating Docker Compose files..."
          EXIT_CODE=0
          
          # Find all compose files
          for compose_file in $(find stacks -name "compose.yml" -o -name "compose.yaml" 2>/dev/null); do
            echo "Checking $compose_file..."
            stack_dir=$(dirname "$compose_file")
            
            # Create a dummy .env file for validation if it doesn't exist
            if [ ! -f "$stack_dir/.env" ]; then
              touch "$stack_dir/.env.tmp"
              ENV_FILE="$stack_dir/.env.tmp"
            else
              ENV_FILE=""
            fi
            
            # Validate compose file syntax (using docker compose config --quiet)
            cd "$stack_dir"
            if docker compose config --quiet 2>&1 || true; then
              echo "  ‚úÖ $compose_file is valid"
            else
              echo "::warning file=$compose_file::Docker Compose validation warning (may be due to missing .env)"
            fi
            cd - > /dev/null
            
            # Clean up temp file
            [ -n "$ENV_FILE" ] && rm -f "$ENV_FILE"
          done
          
          echo "compose_valid=true" >> $GITHUB_OUTPUT

      # ----------------------------------------------------------------------
      # Komodo Resource Schema Validation
      # ----------------------------------------------------------------------
      - name: Validate Komodo resource schema
        id: validate-schema
        run: |
          echo "üìê Validating Komodo resource schema..."
          
          python3 << 'EOF'
          import tomllib
          import sys
          
          errors = []
          warnings = []
          
          # Validate stacks.toml
          try:
              with open('stacks/stacks.toml', 'rb') as f:
                  stacks = tomllib.load(f)
              for stack in stacks.get('stack', []):
                  name = stack.get('name', 'unknown')
                  config = stack.get('config', {})
                  
                  # Required fields
                  if not stack.get('name'):
                    errors.append(f"Stack missing 'name' field")
                  if not config.get('server'):
                    errors.append(f"Stack '{name}' missing 'server' in config")
                  if not config.get('run_directory'):
                    errors.append(f"Stack '{name}' missing 'run_directory' in config")
                  
                  # Validate tags include environment tag
                  tags = stack.get('tags', [])
                  if MATCH_TAG not in tags:
                    warnings.append(f"Stack '{name}' missing '{MATCH_TAG}' tag")

                  # Validate linked_repo matches expected pattern (repo-per-server)
                  linked_repo = config.get('linked_repo', '')
                  if linked_repo and not linked_repo.startswith(os.environ.get('REPO_NAME', 'infra-deploy')):
                    warnings.append(f"Stack '{name}' has unexpected linked_repo: {linked_repo}")
          except Exception as e:
              errors.append(f"Failed to parse stacks.toml: {e}")
          
          # Validate servers.toml
          try:
              with open('servers/servers.toml', 'rb') as f:
                  servers = tomllib.load(f)
              server_names = [s.get('name') for s in servers.get('server', [])]
              
              # Check all stacks reference valid servers
              with open('stacks/stacks.toml', 'rb') as f:
                  stacks = tomllib.load(f)
              for stack in stacks.get('stack', []):
                  server = stack.get('config', {}).get('server')
                  if server and server not in server_names:
                      errors.append(f"Stack '{stack.get('name')}' references unknown server '{server}'")
                      
          except Exception as e:
              errors.append(f"Failed to validate server references: {e}")
          
          # Output results
          for warning in warnings:
              print(f"::warning::{warning}")
          
          for error in errors:
              print(f"::error::{error}")
          
          if errors:
              print(f"\n‚ùå Schema validation failed with {len(errors)} error(s)")
              sys.exit(1)
          else:
              print(f"\n‚úÖ Schema validation passed ({len(warnings)} warning(s))")
              sys.exit(0)
          EOF

      # ----------------------------------------------------------------------
      # Change Detection - Compare TOML files against Komodo current state
      # ----------------------------------------------------------------------
      - name: Detect changes against Komodo state
        id: detect-changes
        env:
          KOMODO_API_URL: ${{ secrets.KOMODO_API_URL }}
          KOMODO_API_KEY: ${{ secrets.KOMODO_API_KEY }}
          KOMODO_API_SECRET: ${{ secrets.KOMODO_API_SECRET }}
          DEBUG_KOMODO_PAYLOADS: ${{ vars.KOMODO_DEBUG_PAYLOADS || 'false' }}
        run: |
          echo "üîÑ Comparing desired state against Komodo current state..."
          
          python3 << 'EOF'
          import tomllib
          import json
          import requests
          import os
          
          API_URL = os.environ.get('KOMODO_API_URL')
          API_KEY = os.environ.get('KOMODO_API_KEY')
          API_SECRET = os.environ.get('KOMODO_API_SECRET')
          
          MATCH_TAG = os.environ.get('ENVIRONMENT')
          
          headers = {
              "Content-Type": "application/json",
              "X-API-KEY": API_KEY,
              "X-API-SECRET": API_SECRET
          }
          
          def api_read(request_type, params=None):
              """Query Komodo read API"""
              try:
                  resp = requests.post(
                      f"{API_URL}/read",
                      headers=headers,
                      json={"type": request_type, "params": params or {}}
                  )
                  data = resp.json()
                  if os.environ.get("DEBUG_KOMODO_PAYLOADS") == "true":
                      print(f"\n--- RAW {request_type} RESPONSE ---")
                      try:
                          print(json.dumps(data, indent=2)[:20000])
                      except Exception:
                          print(str(data)[:20000])
                  if "error" in data:
                      # Some endpoints may return partial data with an error (e.g., missing file contents).
                      if isinstance(data, dict) and len(data.keys()) > 1:
                          print(f"API Warning ({request_type}): {data['error']}")
                          return [data]
                      print(f"API Error ({request_type}): {data['error']}")
                      return []
                  # API returns a list directly for List* operations
                  return data if isinstance(data, list) else [data] if data else []
              except Exception as e:
                  print(f"API Exception ({request_type}): {e}")
                  return []

          def extract_id(value):
              if isinstance(value, dict) and "$oid" in value:
                  return value.get("$oid")
              return value

          def get_tags(query=None):
              params = {"query": query} if query else {}
              tags = api_read("ListTags", params)
              return tags if isinstance(tags, list) else []

          def get_tag_id_by_name(name):
              tags = get_tags({"name": name})
              for tag in tags:
                  if tag.get("name") == name:
                      return extract_id(tag.get("id") or tag.get("_id"))
              return None

          def get_komodo_resources(resource_type, desired_names=None):
              """Get detailed resources; use list to discover names, then fetch full details."""
              list_map = {
                  "stack": "ListStacks",
                  "repo": "ListRepos",
                  "server": "ListServers"
              }
              get_map = {
                  "stack": "GetStack",
                  "repo": "GetRepo",
                  "server": "GetServer"
              }
              param_key = {
                  "stack": "stack",
                  "repo": "repo",
                  "server": "server"
              }

              tag_id = get_tag_id_by_name(MATCH_TAG)
              query_tags = [tag_id] if tag_id else [MATCH_TAG]
              resources = api_read(list_map[resource_type], {"query": {"tags": query_tags}})

              # If servers exist without the environment tag but have matching names,
              # include them so we don't treat them as newly added.
              if resource_type == "server" and desired_names:
                  all_servers = api_read("ListServers", {})
                  tagged_names = {r.get("name") for r in resources if r.get("name")}
                  for srv in all_servers:
                      name = srv.get("name")
                      if name and name in desired_names and name not in tagged_names:
                          resources.append(srv)

              resources_by_name = {r.get("name"): r for r in resources if r.get("name")}
              names = sorted(resources_by_name.keys())
              detailed = {}
              for name in names:
                  list_item = resources_by_name.get(name, {})
                  detail = api_read(get_map[resource_type], {param_key[resource_type]: name})

                  # api_read returns list for list ops; Get* usually returns object
                  if isinstance(detail, list) and detail:
                      detail = detail[0]

                  if not isinstance(detail, dict) or not detail.get("name"):
                      # Try fetching by id if available
                      raw_id = list_item.get("id") or list_item.get("_id")
                      obj_id = extract_id(raw_id)
                      if obj_id:
                          detail = api_read(get_map[resource_type], {"id": obj_id})
                          if isinstance(detail, list) and detail:
                              detail = detail[0]

                  if isinstance(detail, dict) and detail.get("name"):
                      detailed[detail.get("name")] = detail
                  else:
                      # Fallback to list data if detail fetch fails
                      detailed[name] = list_item or {"name": name}

              return detailed
          
          def get_all_servers():
              """Get all servers to build ID-to-name mapping"""
              # Fetch ALL servers (not just tagged) to resolve server_id references
              resources = api_read("ListServers", {})
              return {r.get("id"): r.get("name") for r in resources if r.get("id") and r.get("name")}

          def get_all_repos():
              """Get all repos to build ID-to-name mapping"""
              resources = api_read("ListRepos", {})
              return {r.get("id"): r.get("name") for r in resources if r.get("id") and r.get("name")}

          def get_all_tags():
              """Get all tags to build ID-to-name mapping"""
              resources = get_tags()
              mapping = {}
              for tag in resources:
                  tag_id = extract_id(tag.get("id") or tag.get("_id"))
                  name = tag.get("name")
                  if tag_id and name:
                      mapping[tag_id] = name
              return mapping
          
          # Build server ID to name mapping for resolving server references
          SERVER_ID_TO_NAME = get_all_servers()
          REPO_ID_TO_NAME = get_all_repos()
          TAG_ID_TO_NAME = get_all_tags()
          print(f"Loaded {len(SERVER_ID_TO_NAME)} servers for ID mapping")
          
          def get_desired_resources(resource_type, file_path):
              """Get desired resources from TOML file"""
              try:
                  with open(file_path, 'rb') as f:
                      data = tomllib.load(f)
                  resources = data.get(resource_type, [])
                  # Filter by match_tag
                  return {
                      r.get("name"): r 
                      for r in resources 
                      if r.get("name") and MATCH_TAG in r.get("tags", [])
                  }
              except Exception as e:
                  print(f"Error loading {file_path}: {e}")
                  return {}
          
          def normalize_value(val):
              """Normalize values for comparison (handle None, empty strings, etc.)."""
              if val is None:
                  return None
              if isinstance(val, str):
                  cleaned = val.strip()
                  return cleaned if cleaned != "" else None
              if isinstance(val, bool):
                  return val
              if isinstance(val, (int, float)):
                  return val
              if isinstance(val, list):
                  normalized = []
                  for item in val:
                      n = normalize_value(item)
                      if n is not None:
                          normalized.append(n)
                  # Sort list items by deterministic string to make order-insensitive
                  return tuple(sorted(
                      normalized,
                      key=lambda x: json.dumps(x, sort_keys=True) if isinstance(x, (dict, list)) else str(x)
                  ))
              if isinstance(val, dict):
                  normalized = {}
                  for k, v in val.items():
                      n = normalize_value(v)
                      if n is not None:
                          normalized[k] = n
                  return normalized
              return str(val).strip()

          def get_current_value(desired_key, current_info):
              """Resolve current value for a desired config key, handling known aliases."""
              alias_map = {
                  "linked_repo": ["linked_repo", "repo"],
                  "repo": ["repo", "linked_repo"],
              }
              for key in alias_map.get(desired_key, [desired_key]):
                  if key in current_info:
                      value = current_info.get(key)
                      if key == "linked_repo" and isinstance(value, str) and value in REPO_ID_TO_NAME:
                          return REPO_ID_TO_NAME.get(value)
                      return value
              return None

          def has_current_key(desired_key, current_info):
              alias_map = {
                  "linked_repo": ["linked_repo", "repo"],
                  "repo": ["repo", "linked_repo"],
              }
              return any(key in current_info for key in alias_map.get(desired_key, [desired_key]))

          def is_object_id(value):
              if not isinstance(value, str):
                  return False
              v = value.strip()
              return len(v) == 24 and all(c in "0123456789abcdef" for c in v.lower())

          def compare_config(desired, current, resource_type):
              """Compare configs to detect meaningful modifications."""
              # TOML uses 'config', API uses 'info'
              desired_config = desired.get("config", {})
              current_info = {
                  **(current.get("info") or {}),
                  **(current.get("config") or {})
              }
              
              name = desired.get('name', 'unknown')
              differences = []

              # If we couldn't fetch details, skip diff to avoid false positives
              if not current_info:
                  print(f"  SKIP: {name} - details unavailable from API")
                  return False

              # Compare tags (top-level)
              desired_tags = normalize_value(desired.get("tags", []))
              current_tags_raw = current.get("tags") or current_info.get("tags") or []
              if current_tags_raw and all(is_object_id(str(t)) for t in current_tags_raw):
                  # Map IDs to names when possible
                  mapped = [TAG_ID_TO_NAME.get(t) for t in current_tags_raw if TAG_ID_TO_NAME.get(t)]
                  current_tags_norm = normalize_value(mapped) if mapped else None
              else:
                  current_tags_norm = normalize_value([t for t in current_tags_raw if not is_object_id(str(t))])
              if desired_tags is not None and current_tags_norm is not None and desired_tags != current_tags_norm:
                  differences.append(f"tags: '{desired_tags}' vs '{current_tags_norm}'")
              
              # Compare server assignment (stacks and repos have server references)
              if resource_type in ["stack", "repo"]:
                  desired_server = desired_config.get("server")
                  current_server_id = current_info.get("server_id") or current_info.get("server")
                  current_server_id = extract_id(current_server_id)
                  current_server = SERVER_ID_TO_NAME.get(current_server_id) if current_server_id else None

                  if os.environ.get("DEBUG_KOMODO_PAYLOADS") == "true" and current_server_id and not current_server:
                    print(f"DEBUG: server_id {current_server_id} not found in mapping for {name}")
                  
                  if desired_server and desired_server != current_server:
                      differences.append(f"server: '{desired_server}' vs '{current_server}'")
              
              # Compare config fields present in desired config (order-insensitive)
              ignored_keys = {"server"}
              for key, desired_val in desired_config.items():
                  if key in ignored_keys:
                      continue

                  # Skip comparison if Komodo didn't return this key in config
                  if not has_current_key(key, current_info):
                      continue

                  desired_norm = normalize_value(desired_val)
                  if desired_norm is None:
                      continue

                  current_val = get_current_value(key, current_info)
                  if current_val is None:
                      continue
                  current_norm = normalize_value(current_val)

                  if desired_norm != current_norm:
                      differences.append(f"{key}: '{desired_norm}' vs '{current_norm}'")

              if differences:
                  print(f"  MODIFIED: {name} - {differences}")
              else:
                  print(f"  UNCHANGED: {name}")
              
              return len(differences) > 0

          def detect_changes(resource_type, file_path):
              """Detect added, removed, and modified resources"""
              desired = get_desired_resources(resource_type, file_path)
              desired_names = set(desired.keys())
              current = get_komodo_resources(resource_type, desired_names if resource_type == "server" else None)
              
              current_names = set(current.keys())
              
              added = desired_names - current_names
              removed = current_names - desired_names
              
              # Check for modifications in existing resources
              modified = set()
              for name in desired_names & current_names:
                  if compare_config(desired[name], current[name], resource_type):
                      modified.add(name)
              
              return {
                  "added": sorted(added),
                  "removed": sorted(removed),
                  "modified": sorted(modified),
                  "current": sorted(current_names),
                  "desired": sorted(desired_names)
              }
          
          # Detect changes for each resource type
          print("=" * 60)
          print("üìä CHANGE DETECTION REPORT")
          print("=" * 60)
          
          results = {}
          
          # Stacks
          print("\nüì¶ STACKS:")
          stacks = detect_changes("stack", "stacks/stacks.toml")
          results["stacks"] = stacks
          print(f"  ‚ûï Added:    {stacks['added'] or 'None'}")
          print(f"  ‚ûñ Removed:  {stacks['removed'] or 'None'}")
          print(f"  ‚úèÔ∏è  Modified: {stacks['modified'] or 'None'}")
          
          # Repos
          print("\nüìÅ REPOS:")
          repos = detect_changes("repo", "repos/repos.toml")
          results["repos"] = repos
          print(f"  ‚ûï Added:    {repos['added'] or 'None'}")
          print(f"  ‚ûñ Removed:  {repos['removed'] or 'None'}")
          print(f"  ‚úèÔ∏è  Modified: {repos['modified'] or 'None'}")
          
          # Servers
          print("\nüñ•Ô∏è  SERVERS:")
          servers = detect_changes("server", "servers/servers.toml")
          results["servers"] = servers
          print(f"  ‚ûï Added:    {servers['added'] or 'None'}")
          print(f"  ‚ûñ Removed:  {servers['removed'] or 'None'}")
          print(f"  ‚úèÔ∏è  Modified: {servers['modified'] or 'None'}")
          
          # Check if any changes detected
          changes_detected = any(
              results[rt][change_type]
              for rt in ["stacks", "repos", "servers"]
              for change_type in ["added", "removed", "modified"]
          )
          
          print("\n" + "=" * 60)
          print(f"üîç Changes Detected: {'YES' if changes_detected else 'NO'}")
          print("=" * 60)
          
          # Warnings for removals
          if stacks["removed"]:
              print(f"\n::warning::Stacks will be REMOVED: {', '.join(stacks['removed'])}")
          if repos["removed"]:
              print(f"\n::warning::Repos will be REMOVED: {', '.join(repos['removed'])}")
          if servers["removed"]:
              print(f"\n::warning::Servers will be REMOVED: {', '.join(servers['removed'])}")
          
          # Write outputs to GITHUB_OUTPUT (newline-separated for display)
          def write_output(name, items):
              # Use newline for display, but escape for GitHub output
              value = "\\n".join(items) if items else ""
              with open(os.environ["GITHUB_OUTPUT"], "a") as f:
                  f.write(f"{name}={value}\n")
          
          write_output("changes_detected", [str(changes_detected).lower()])
          write_output("stacks_added", stacks["added"])
          write_output("stacks_removed", stacks["removed"])
          write_output("stacks_modified", stacks["modified"])
          write_output("stacks_current", stacks["current"])
          write_output("stacks_desired", stacks["desired"])
          write_output("repos_added", repos["added"])
          write_output("repos_removed", repos["removed"])
          write_output("repos_modified", repos["modified"])
          write_output("repos_current", repos["current"])
          write_output("repos_desired", repos["desired"])
          write_output("servers_added", servers["added"])
          write_output("servers_removed", servers["removed"])
          write_output("servers_modified", servers["modified"])
          write_output("servers_current", servers["current"])
          write_output("servers_desired", servers["desired"])
          
          EOF

      # ----------------------------------------------------------------------
      # Final Validation Status
      # ----------------------------------------------------------------------
      - name: Validation summary
        id: final-status
        run: |
          echo "üìã Validation Summary"
          echo "===================="
          echo "Secret Scan: ${{ steps.secret-scan.outputs.unencrypted_found == 'false' && '‚úÖ Passed' || '‚ùå Failed' }}"
          echo "TOML Syntax: ${{ steps.validate-toml.outputs.toml_valid == 'true' && '‚úÖ Passed' || '‚ùå Failed' }}"
          echo "Compose Files: ${{ steps.validate-compose.outputs.compose_valid == 'true' && '‚úÖ Passed' || '‚ö†Ô∏è Warnings' }}"
          echo "Schema: ‚úÖ Passed"
          echo ""
          echo "passed=true" >> $GITHUB_OUTPUT

  # ============================================================================
  # DEPLOY JOB
  # Deploys changes to Komodo via API
  # ============================================================================
  deploy:
    name: Deploy to Komodo
    runs-on: ubuntu-latest
    needs: validate
    if: |
      needs.validate.outputs.validation_passed == 'true' && 
      inputs.dry_run != 'true'
    environment: ${{ inputs.environment }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python for deployment
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Setup deployment tools
        run: |
          # jq and curl are pre-installed on ubuntu-latest
          # Install requests for any Python API calls if needed
          pip install requests -q

      # ----------------------------------------------------------------------
      # Komodo API Helper Functions
      # ----------------------------------------------------------------------
      - name: Setup Komodo API client
        id: setup-api
        run: |
          # Create API client script with execution polling
          cat > /tmp/komodo-api.sh << 'SCRIPT'
          #!/bin/bash
          
          # Wait for a Komodo execution to complete
          # Usage: wait_for_execution <execution_id> [timeout_seconds]
          wait_for_execution() {
            local exec_id="$1"
            local timeout="${2:-60}"
            local start_time=$(date +%s)
            
            if [ -z "$exec_id" ]; then
              echo "No execution ID provided, skipping wait"
              return 0
            fi
            
            echo "‚è≥ Waiting for execution $exec_id..."
            
            while true; do
              local elapsed=$(($(date +%s) - start_time))
              if [ $elapsed -ge $timeout ]; then
                echo "‚ö†Ô∏è Timeout after ${timeout}s, continuing..."
                return 0
              fi
              
              local status_response=$(curl -s -X POST \
                -H "Content-Type: application/json" \
                -H "X-API-KEY: $KOMODO_API_KEY" \
                -H "X-API-SECRET: $KOMODO_API_SECRET" \
                -d "{\"type\": \"GetExecution\", \"params\": {\"execution\": \"$exec_id\"}}" \
                "$KOMODO_API_URL/read" 2>/dev/null)
              
              local status=$(echo "$status_response" | jq -r '.status // "Unknown"' 2>/dev/null)
              
              case "$status" in
                "Complete"|"Ok")
                  echo "‚úÖ Execution completed (${elapsed}s)"
                  return 0
                  ;;
                "InProgress"|"Pending"|"Running")
                  sleep 1
                  ;;
                "Unknown"|"")
                  # API might not support GetExecution, use short wait
                  sleep 2
                  echo "‚úÖ Proceeding after ${elapsed}s"
                  return 0
                  ;;
                *)
                  echo "‚ö†Ô∏è Execution status: $status"
                  return 0
                  ;;
              esac
            done
          }
          
          # Extract execution ID from response
          get_execution_id() {
            local response="$1"
            echo "$response" | jq -r '._id["$oid"] // ._id // .execution_id // .id // empty' 2>/dev/null
          }
          
          export -f wait_for_execution
          export -f get_execution_id
          SCRIPT
          
          chmod +x /tmp/komodo-api.sh
          source /tmp/komodo-api.sh
          echo "‚úÖ Komodo API client configured"
        env:
          KOMODO_API_URL: ${{ secrets.KOMODO_API_URL }}
          KOMODO_API_KEY: ${{ secrets.KOMODO_API_KEY }}
          KOMODO_API_SECRET: ${{ secrets.KOMODO_API_SECRET }}

      # ----------------------------------------------------------------------
      # Step 1: Handle Removed Stacks BEFORE sync (cleanup old resources)
      # ----------------------------------------------------------------------
      - name: Destroy removed stacks
        if: needs.validate.outputs.stacks_removed != ''
        run: |
          echo "üóëÔ∏è Destroying removed stacks..."
          
          REMOVED_STACKS="${{ needs.validate.outputs.stacks_removed }}"
          
          for stack in $REMOVED_STACKS; do
            echo "Destroying stack: $stack"
            
            RESPONSE=$(curl -s -X POST \
              -H "Content-Type: application/json" \
              -H "X-API-KEY: ${{ secrets.KOMODO_API_KEY }}" \
              -H "X-API-SECRET: ${{ secrets.KOMODO_API_SECRET }}" \
              -d "{
                \"type\": \"DestroyStack\",
                \"params\": {
                  \"stack\": \"$stack\"
                }
              }" \
              "${{ secrets.KOMODO_API_URL }}/execute")
            
            echo "Response for $stack: $RESPONSE"
            
            if echo "$RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
              echo "::warning::Failed to destroy stack $stack: $(echo $RESPONSE | jq -r '.error')"
            else
              echo "‚úÖ Stack $stack destruction initiated"
            fi
          done
        env:
          KOMODO_API_URL: ${{ secrets.KOMODO_API_URL }}

      # ----------------------------------------------------------------------
      # Step 3: Read resource_sync.toml and create/update ResourceSync via API
      # ----------------------------------------------------------------------
      - name: Create or update ResourceSync from file
        id: ensure-resource-sync
        run: |
          echo "üîß Reading ResourceSync config from resource_sync.toml..."
          
          # Parse resource_sync.toml and extract config (tomllib is built-in to Python 3.11+)
          CONFIG_JSON=$(python3 << 'EOF'
          import tomllib
          import json
          
          with open('resource_sync.toml', 'rb') as f:
              config = tomllib.load(f)
          
          rs = config.get('resource_sync', {})
          print(json.dumps({
              "name": rs.get('name', ''),
              "tags": rs.get('tags', []),
              "config": rs.get('config', {})
          }))
          EOF
          )
          
          echo "Parsed config: $CONFIG_JSON"
          
          RS_NAME=$(echo "$CONFIG_JSON" | jq -r '.name')
          RS_TAGS=$(echo "$CONFIG_JSON" | jq -c '.tags')
          RS_CONFIG=$(echo "$CONFIG_JSON" | jq -c '.config')
          
          echo "ResourceSync name: $RS_NAME"
          echo "ResourceSync tags: $RS_TAGS"
          echo "ResourceSync config: $RS_CONFIG"

              # Enforce delete=false
              RS_CONFIG="$RS_CONFIG" python3 -c "import json,os,sys; cfg=json.loads(os.environ.get('RS_CONFIG','{}')); flag=cfg.get('delete', None); (print('‚úÖ resource_sync.config.delete is false') if flag is False else (print(f'::error::CRITICAL: resource_sync.config.delete must be false (found: {flag})') or sys.exit(1)))"
          
          # Verify match_tags is present
          MATCH_TAGS=$(echo "$RS_CONFIG" | jq -c '.match_tags // empty')
          if [ -z "$MATCH_TAGS" ] || [ "$MATCH_TAGS" = "null" ]; then
            echo "::error::CRITICAL: match_tags is missing from config! This would delete all resources."
            exit 1
          fi
          echo "‚úÖ match_tags present: $MATCH_TAGS"
          
          # Check if ResourceSync exists
          CHECK_RESPONSE=$(curl -s -X POST \
            -H "Content-Type: application/json" \
            -H "X-API-KEY: ${{ secrets.KOMODO_API_KEY }}" \
            -H "X-API-SECRET: ${{ secrets.KOMODO_API_SECRET }}" \
            -d "{
              \"type\": \"GetResourceSync\",
              \"params\": {
                \"sync\": \"$RS_NAME\"
              }
            }" \
            "${{ secrets.KOMODO_API_URL }}/read")
          
          echo "Check response: $CHECK_RESPONSE"
          
          # If not found, create it; otherwise update it
          if echo "$CHECK_RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
            echo "üìù ResourceSync not found, creating..."
            
            CREATE_RESPONSE=$(curl -s -X POST \
              -H "Content-Type: application/json" \
              -H "X-API-KEY: ${{ secrets.KOMODO_API_KEY }}" \
              -H "X-API-SECRET: ${{ secrets.KOMODO_API_SECRET }}" \
              -d "{
                \"type\": \"CreateResourceSync\",
                \"params\": {
                  \"name\": \"$RS_NAME\",
                  \"tags\": $RS_TAGS,
                  \"config\": $RS_CONFIG
                }
              }" \
              "${{ secrets.KOMODO_API_URL }}/write")
            
            echo "Create response: $CREATE_RESPONSE"
            
            if echo "$CREATE_RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
              echo "::error::Failed to create ResourceSync: $(echo $CREATE_RESPONSE | jq -r '.error')"
              exit 1
            fi
            
            echo "‚úÖ ResourceSync created from resource_sync.toml"
          else
            echo "üìù ResourceSync exists, updating config..."
            
            UPDATE_RESPONSE=$(curl -s -X POST \
              -H "Content-Type: application/json" \
              -H "X-API-KEY: ${{ secrets.KOMODO_API_KEY }}" \
              -H "X-API-SECRET: ${{ secrets.KOMODO_API_SECRET }}" \
              -d "{
                \"type\": \"UpdateResourceSync\",
                \"params\": {
                  \"id\": \"$RS_NAME\",
                  \"tags\": $RS_TAGS,
                  \"config\": $RS_CONFIG
                }
              }" \
              "${{ secrets.KOMODO_API_URL }}/write")
            
            echo "Update response: $UPDATE_RESPONSE"
            echo "‚úÖ ResourceSync updated from resource_sync.toml"
          fi
          
          # Export name for subsequent steps
          echo "sync_name=$RS_NAME" >> $GITHUB_OUTPUT
        env:
          KOMODO_API_URL: ${{ secrets.KOMODO_API_URL }}

      - name: Sync Komodo resources
        id: sync-resources
        run: |
          echo "üîÑ Syncing Komodo resources..."
          
          RESPONSE=$(curl -s -X POST \
            -H "Content-Type: application/json" \
            -H "X-API-KEY: ${{ secrets.KOMODO_API_KEY }}" \
            -H "X-API-SECRET: ${{ secrets.KOMODO_API_SECRET }}" \
            -d '{
              "type": "RunSync",
              "params": {
                "sync": "${{ env.RESOURCE_SYNC_NAME }}"
              }
            }' \
            "${{ secrets.KOMODO_API_URL }}/execute")
          
          echo "Response: $RESPONSE"
          
          if echo "$RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
            echo "::error::Failed to sync resources: $(echo $RESPONSE | jq -r '.error')"
            exit 1
          fi
          
          # Extract execution ID and wait for completion
          EXECUTION_ID=$(echo "$RESPONSE" | jq -r '._id["$oid"] // ._id // .execution_id // .id // empty')
          echo "execution_id=$EXECUTION_ID" >> $GITHUB_OUTPUT
          
          if [ -n "$EXECUTION_ID" ]; then
            echo "‚è≥ Waiting for sync to complete (execution: $EXECUTION_ID)..."
            START_TIME=$(date +%s)
            TIMEOUT=30
            
            while true; do
              ELAPSED=$(($(date +%s) - START_TIME))
              if [ $ELAPSED -ge $TIMEOUT ]; then
                echo "‚úÖ Proceeding after ${ELAPSED}s"
                break
              fi
              
              STATUS_RESP=$(curl -s -X POST \
                -H "Content-Type: application/json" \
                -H "X-API-KEY: ${{ secrets.KOMODO_API_KEY }}" \
                -H "X-API-SECRET: ${{ secrets.KOMODO_API_SECRET }}" \
                -d "{\"type\": \"GetExecution\", \"params\": {\"execution\": \"$EXECUTION_ID\"}}" \
                "${{ secrets.KOMODO_API_URL }}/read" 2>/dev/null || echo '{}')
              
              STATUS=$(echo "$STATUS_RESP" | jq -r '.status // "Unknown"' 2>/dev/null)
              
              if [ "$STATUS" = "Complete" ] || [ "$STATUS" = "Ok" ]; then
                echo "‚úÖ Sync completed in ${ELAPSED}s"
                break
              elif [ "$STATUS" = "InProgress" ] || [ "$STATUS" = "Pending" ]; then
                sleep 1
              else
                echo "‚úÖ Proceeding (status: $STATUS)"
                break
              fi
            done
          fi
          
          echo "‚úÖ Resource sync initiated"
        env:
          KOMODO_API_URL: ${{ secrets.KOMODO_API_URL }}

      # ----------------------------------------------------------------------
      # Step 4: Clone All Repos (if not already cloned)
      # ResourceSync only creates the repo resources, doesn't clone them
      # We need to clone each repo on each server
      # ----------------------------------------------------------------------
      - name: Clone repositories in Komodo
        id: clone-repos
        run: |
          echo "üì• Cloning repositories in Komodo..."
          
          # Get all repos with our tag
          REPOS_RESPONSE=$(curl -s -X POST \
            -H "Content-Type: application/json" \
            -H "X-API-KEY: ${{ secrets.KOMODO_API_KEY }}" \
            -H "X-API-SECRET: ${{ secrets.KOMODO_API_SECRET }}" \
            -d '{
              "type": "ListRepos",
              "params": {
                "query": {
                  "tags": ["${{ env.ENVIRONMENT }}"]
                }
              }
            }' \
            "${{ secrets.KOMODO_API_URL }}/read")
          
          echo "Found repos: $(echo "$REPOS_RESPONSE" | jq -r '.[].name' 2>/dev/null || echo 'none')"
          
          # Clone each repo and collect execution IDs
          EXEC_IDS=()
          for REPO_NAME in $(echo "$REPOS_RESPONSE" | jq -r '.[].name' 2>/dev/null | sort | uniq); do
            echo "üì• Cloning $REPO_NAME..."
            
            RESPONSE=$(curl -s -X POST \
              -H "Content-Type: application/json" \
              -H "X-API-KEY: ${{ secrets.KOMODO_API_KEY }}" \
              -H "X-API-SECRET: ${{ secrets.KOMODO_API_SECRET }}" \
              -d "{
                \"type\": \"CloneRepo\",
                \"params\": {
                  \"repo\": \"$REPO_NAME\"
                }
              }" \
              "${{ secrets.KOMODO_API_URL }}/execute")
            
            # Clone may fail if already cloned - that's OK
            if echo "$RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
              ERROR_MSG=$(echo $RESPONSE | jq -r '.error')
              if [[ "$ERROR_MSG" == *"already"* ]] || [[ "$ERROR_MSG" == *"exists"* ]]; then
                echo "  ‚ÑπÔ∏è $REPO_NAME already cloned"
              else
                echo "  ‚ö†Ô∏è $REPO_NAME: $ERROR_MSG"
              fi
            else
              EXEC_ID=$(echo "$RESPONSE" | jq -r '._id["$oid"] // ._id // empty')
              [ -n "$EXEC_ID" ] && EXEC_IDS+=("$EXEC_ID")
              echo "  ‚úÖ $REPO_NAME clone initiated"
            fi
          done
          
          # Wait for all clones to complete (with timeout)
          if [ ${#EXEC_IDS[@]} -gt 0 ]; then
            echo "‚è≥ Waiting for ${#EXEC_IDS[@]} clone(s) to complete..."
            sleep 3  # Brief wait for clones to start
          fi
        env:
          KOMODO_API_URL: ${{ secrets.KOMODO_API_URL }}

      # ----------------------------------------------------------------------
      # Step 5: Pull All Repos (triggers decryption via on_pull hook)
      # ----------------------------------------------------------------------
      - name: Pull repositories in Komodo
        id: pull-repos
        run: |
          echo "üì• Pulling repositories in Komodo..."
          
          # Get all repos with our tag
          REPOS_RESPONSE=$(curl -s -X POST \
            -H "Content-Type: application/json" \
            -H "X-API-KEY: ${{ secrets.KOMODO_API_KEY }}" \
            -H "X-API-SECRET: ${{ secrets.KOMODO_API_SECRET }}" \
            -d '{
              "type": "ListRepos",
              "params": {
                "query": {
                  "tags": ["${{ env.ENVIRONMENT }}"]
                }
              }
            }' \
            "${{ secrets.KOMODO_API_URL }}/read")
          
          # Pull each repo and collect execution IDs
          EXEC_IDS=()
          FAILED=0
          for REPO_NAME in $(echo "$REPOS_RESPONSE" | jq -r '.[].name' 2>/dev/null | sort | uniq); do
            echo "üì• Pulling $REPO_NAME..."
            
            RESPONSE=$(curl -s -X POST \
              -H "Content-Type: application/json" \
              -H "X-API-KEY: ${{ secrets.KOMODO_API_KEY }}" \
              -H "X-API-SECRET: ${{ secrets.KOMODO_API_SECRET }}" \
              -d "{
                \"type\": \"PullRepo\",
                \"params\": {
                  \"repo\": \"$REPO_NAME\"
                }
              }" \
              "${{ secrets.KOMODO_API_URL }}/execute")
            
            if echo "$RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
              echo "  ‚ùå $REPO_NAME: $(echo $RESPONSE | jq -r '.error')"
              FAILED=1
            else
              EXEC_ID=$(echo "$RESPONSE" | jq -r '._id["$oid"] // ._id // empty')
              [ -n "$EXEC_ID" ] && EXEC_IDS+=("$EXEC_ID")
              echo "  ‚úÖ $REPO_NAME pull initiated"
            fi
          done
          
          if [ $FAILED -eq 1 ]; then
            echo "::warning::Some repository pulls failed"
          fi
          
          # Wait for pulls to complete (decryption hooks run during pull)
          if [ ${#EXEC_IDS[@]} -gt 0 ]; then
            echo "‚è≥ Waiting for ${#EXEC_IDS[@]} pull(s) and decryption to complete..."
            START_TIME=$(date +%s)
            TIMEOUT=20
            
            # Poll first execution as a proxy for all
            FIRST_EXEC="${EXEC_IDS[0]}"
            while true; do
              ELAPSED=$(($(date +%s) - START_TIME))
              if [ $ELAPSED -ge $TIMEOUT ]; then
                echo "‚úÖ Proceeding after ${ELAPSED}s"
                break
              fi
              
              STATUS_RESP=$(curl -s -X POST \
                -H "Content-Type: application/json" \
                -H "X-API-KEY: ${{ secrets.KOMODO_API_KEY }}" \
                -H "X-API-SECRET: ${{ secrets.KOMODO_API_SECRET }}" \
                -d "{\"type\": \"GetExecution\", \"params\": {\"execution\": \"$FIRST_EXEC\"}}" \
                "${{ secrets.KOMODO_API_URL }}/read" 2>/dev/null || echo '{}')
              
              STATUS=$(echo "$STATUS_RESP" | jq -r '.status // "Unknown"' 2>/dev/null)
              
              if [ "$STATUS" = "Complete" ] || [ "$STATUS" = "Ok" ]; then
                echo "‚úÖ Pulls completed in ${ELAPSED}s"
                break
              elif [ "$STATUS" = "InProgress" ] || [ "$STATUS" = "Pending" ]; then
                sleep 1
              else
                echo "‚úÖ Proceeding (status: $STATUS)"
                break
              fi
            done
          fi
          
          echo "‚úÖ Repository pulls completed (decryption triggered)"
        env:
          KOMODO_API_URL: ${{ secrets.KOMODO_API_URL }}

      # ----------------------------------------------------------------------
      # Step 6: Deploy Stacks
      # ----------------------------------------------------------------------
      - name: Deploy stacks
        id: deploy-stacks
        run: |
          echo "üöÄ Deploying stacks..."
          
          FORCE_DEPLOY="${{ inputs.force_deploy }}"
          REDEPLOY_STACKS="${{ inputs.redeploy_stacks }}"
          
          # If specific stacks are requested, deploy them individually
          if [ -n "$REDEPLOY_STACKS" ]; then
            echo "üì¶ Targeted redeploy requested for: $REDEPLOY_STACKS"
            
            IFS=',' read -ra STACKS <<< "$REDEPLOY_STACKS"
            FAILED_COUNT=0
            SUCCESS_COUNT=0
            
            for STACK in "${STACKS[@]}"; do
              STACK=$(echo "$STACK" | xargs)  # Trim whitespace
              echo "  üîÑ Deploying stack: $STACK"
              
              RESPONSE=$(curl -s -X POST \
                -H "Content-Type: application/json" \
                -H "X-API-KEY: ${{ secrets.KOMODO_API_KEY }}" \
                -H "X-API-SECRET: ${{ secrets.KOMODO_API_SECRET }}" \
                -d "{
                  \"type\": \"DeployStack\",
                  \"params\": {
                    \"stack\": \"$STACK\"
                  }
                }" \
                "${{ secrets.KOMODO_API_URL }}/execute")
              
              if echo "$RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
                echo "::warning::Failed to deploy $STACK: $(echo $RESPONSE | jq -r '.error')"
                ((FAILED_COUNT++))
              else
                EXEC_ID=$(echo "$RESPONSE" | jq -r '.id // empty')
                echo "    ‚úÖ Deployment started (execution: $EXEC_ID)"
                ((SUCCESS_COUNT++))
              fi
            done
            
            echo "üìä Targeted deployment: $SUCCESS_COUNT succeeded, $FAILED_COUNT failed"
            
            if [ "$FAILED_COUNT" -gt 0 ]; then
              exit 1
            fi
          elif [ "$FORCE_DEPLOY" == "true" ]; then
            echo "Force deploy enabled - deploying all stacks"
            DEPLOY_TYPE="BatchDeployStack"
            
            RESPONSE=$(curl -s -X POST \
              -H "Content-Type: application/json" \
              -H "X-API-KEY: ${{ secrets.KOMODO_API_KEY }}" \
              -H "X-API-SECRET: ${{ secrets.KOMODO_API_SECRET }}" \
              -d "{
                \"type\": \"$DEPLOY_TYPE\",
                \"params\": {
                  \"pattern\": \"${{ env.ENVIRONMENT }}-*\"
                }
              }" \
              "${{ secrets.KOMODO_API_URL }}/execute")
            
            echo "Response: $RESPONSE"
            
            # Handle batch response
            if echo "$RESPONSE" | jq -e 'type == "array"' > /dev/null 2>&1; then
              TOTAL=$(echo "$RESPONSE" | jq 'length')
              SUCCESS=$(echo "$RESPONSE" | jq '[.[] | select(.status == "Ok")] | length')
              FAILED=$(echo "$RESPONSE" | jq '[.[] | select(.status != "Ok")] | length')
              
              echo "üìä Batch deployment results: $SUCCESS/$TOTAL succeeded"
              
              if [ "$FAILED" -gt 0 ]; then
                echo "::warning::$FAILED stack(s) failed to deploy"
              fi
            else
              if echo "$RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
                echo "::error::Failed to deploy stacks: $(echo $RESPONSE | jq -r '.error')"
                exit 1
              fi
              echo "‚úÖ Stack deployment initiated"
            fi
          else
            echo "Deploying changed stacks only"
            
            RESPONSE=$(curl -s -X POST \
              -H "Content-Type: application/json" \
              -H "X-API-KEY: ${{ secrets.KOMODO_API_KEY }}" \
              -H "X-API-SECRET: ${{ secrets.KOMODO_API_SECRET }}" \
              -d "{
                \"type\": \"BatchDeployStackIfChanged\",
                \"params\": {
                  \"pattern\": \"${{ env.ENVIRONMENT }}-*\"
                }
              }" \
              "${{ secrets.KOMODO_API_URL }}/execute")
            
            echo "Response: $RESPONSE"
            
            if echo "$RESPONSE" | jq -e 'type == "array"' > /dev/null 2>&1; then
              TOTAL=$(echo "$RESPONSE" | jq 'length')
              SUCCESS=$(echo "$RESPONSE" | jq '[.[] | select(.status == "Ok")] | length')
              FAILED=$(echo "$RESPONSE" | jq '[.[] | select(.status != "Ok")] | length')
              
              echo "üìä Batch deployment results: $SUCCESS/$TOTAL succeeded"
              
              if [ "$FAILED" -gt 0 ]; then
                echo "::warning::$FAILED stack(s) failed to deploy"
              fi
            else
              if echo "$RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
                echo "::error::Failed to deploy stacks: $(echo $RESPONSE | jq -r '.error')"
                exit 1
              fi
              echo "‚úÖ Stack deployment initiated"
            fi
          fi
        env:
          KOMODO_API_URL: ${{ secrets.KOMODO_API_URL }}

      # ----------------------------------------------------------------------
      # Deployment Summary
      # ----------------------------------------------------------------------
      - name: Deployment summary
        run: |
          echo "## üöÄ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Step | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Repository Clone | ‚úÖ Completed |" >> $GITHUB_STEP_SUMMARY
          echo "| Repository Pull | ‚úÖ Completed |" >> $GITHUB_STEP_SUMMARY
          echo "| Resource Sync | ‚úÖ Completed |" >> $GITHUB_STEP_SUMMARY
          echo "| Stack Deployment | ‚úÖ Initiated |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Helper function to format list (newline separated)
          format_list() {
            local items="$1"
            if [ -z "$items" ]; then
              echo "None"
            else
              # Replace escaped newlines with actual newlines, then format as bullet list
              echo "$items" | sed 's/\\n/\n/g' | while read -r item; do
                [ -n "$item" ] && echo "- \`$item\`"
              done
            fi
          }
          
          echo "### üì¶ Stacks" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**‚ûï Added:**" >> $GITHUB_STEP_SUMMARY
          format_list "${{ needs.validate.outputs.stacks_added }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**‚úèÔ∏è Modified:**" >> $GITHUB_STEP_SUMMARY
          format_list "${{ needs.validate.outputs.stacks_modified }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**‚ûñ Removed:**" >> $GITHUB_STEP_SUMMARY
          format_list "${{ needs.validate.outputs.stacks_removed }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**üìç Current (Komodo):**" >> $GITHUB_STEP_SUMMARY
          format_list "${{ needs.validate.outputs.stacks_current }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**üéØ Desired (from TOML):**" >> $GITHUB_STEP_SUMMARY
          format_list "${{ needs.validate.outputs.stacks_desired }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### üìÅ Repos" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**‚ûï Added:**" >> $GITHUB_STEP_SUMMARY
          format_list "${{ needs.validate.outputs.repos_added }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**‚úèÔ∏è Modified:**" >> $GITHUB_STEP_SUMMARY
          format_list "${{ needs.validate.outputs.repos_modified }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**‚ûñ Removed:**" >> $GITHUB_STEP_SUMMARY
          format_list "${{ needs.validate.outputs.repos_removed }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**üìç Current (Komodo):**" >> $GITHUB_STEP_SUMMARY
          format_list "${{ needs.validate.outputs.repos_current }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**üéØ Desired (from TOML):**" >> $GITHUB_STEP_SUMMARY
          format_list "${{ needs.validate.outputs.repos_desired }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### üñ•Ô∏è Servers" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**‚ûï Added:**" >> $GITHUB_STEP_SUMMARY
          format_list "${{ needs.validate.outputs.servers_added }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**‚úèÔ∏è Modified:**" >> $GITHUB_STEP_SUMMARY
          format_list "${{ needs.validate.outputs.servers_modified }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**‚ûñ Removed:**" >> $GITHUB_STEP_SUMMARY
          format_list "${{ needs.validate.outputs.servers_removed }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**üìç Current (Komodo):**" >> $GITHUB_STEP_SUMMARY
          format_list "${{ needs.validate.outputs.servers_current }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**üéØ Desired (from TOML):**" >> $GITHUB_STEP_SUMMARY
          format_list "${{ needs.validate.outputs.servers_desired }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ env.ENVIRONMENT }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Actor:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY

  # ============================================================================
  # NOTIFICATION JOB (Placeholder for Teams integration)
  # ============================================================================
  notify:
    name: Send Notifications
    runs-on: ubuntu-latest
    needs: [validate, deploy]
    if: always()
    
    steps:
      - name: Prepare notification
        run: |
          # Placeholder for Teams notification
          # Will be implemented when Teams webhook is configured
          echo "üì¢ Deployment notification would be sent here"
          echo ""
          echo "Status: ${{ needs.deploy.result }}"
          echo "Environment: ${{ env.ENVIRONMENT }}"
          echo "Commit: ${{ github.sha }}"
          echo "Actor: ${{ github.actor }}"
